\documentclass[a4paper,12pt]{article}
\usepackage{fontspec}
\usepackage{xeCJK}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{titlesec}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{subcaption}

\geometry{left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm}

% Code listing style
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    extendedchars=false % Allow xeCJK to handle Chinese characters
}
\lstset{style=mystyle}

\setCJKmainfont[BoldFont=SimHei, ItalicFont=KaiTi]{Microsoft YaHei}
\setCJKsansfont{SimHei}
\setCJKmonofont{KaiTi}
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt

\title{\textbf{系统架构与性能工程报告}\\ \large xy-core 情感智能体实现细节与实验分析}
\author{Leslie}
\date{2025年12月8日}

\begin{document}

\maketitle

\section{工程概述 (Engineering Overview)}

本报告作为核心研究论文的工程补充，重点阐述 \textbf{xy-core} 平台的实现细节、系统架构以及在边缘计算环境下的性能实验数据。本系统旨在解决 Python 在高并发多模态混合负载（大语言模型推理 + 视觉理解 + 图像生成 + 语音合成）场景下，受限于全局解释器锁（GIL）和 I/O 阻塞导致的性能瓶颈问题。

报告详细介绍了 \textbf{“三层异步隔离架构” (Three-Layer Asynchronous Isolation Architecture)}，并提供了代码级策略、真实性能剖析日志，以及在模拟边缘约束条件下的对比实验数据。

\section{系统架构实现 (System Architecture Implementation)}

系统采用分层架构设计，由核心引擎统一管理所有模块，通过事件总线实现模块间通信，并使用全局任务调度器处理所有任务。

\subsection{架构图与数据流}

系统架构由以下核心组件定义：

\begin{itemize}
    \item \textbf{核心引擎 (CoreEngine)}: 负责管理系统的核心功能和模块，包括模块加载、卸载、初始化和关闭。
    \item \textbf{事件总线 (Event Bus)}: 实现模块间的异步通信，支持事件发布和订阅机制。
    \item \textbf{全局任务调度器 (GlobalTaskScheduler)}: 系统核心调度组件，已全面整合原 \texttt{CPUTaskProcessor} 功能。运行在主 \texttt{asyncio} 事件循环上，负责调度所有类型的任务，包括：
    \begin{itemize}
        \item 任务类型划分：默认异步任务、CPU密集型任务、GPU密集型任务
        \item 任务优先级管理：低、中、高、关键四个优先级
        \item 任务队列：基于优先级的任务队列，支持任务取消和状态管理
        \item Worker管理：CPU线程池和GPU锁机制
    \end{itemize}
    \item \textbf{功能模块 (Function Modules)}: 包括LLM、图像、语音、内存等功能模块，由CoreEngine动态加载和管理。
    \item \textbf{进程间通信 (IPC)}: 使用异步队列进行任务分发，支持任务结果的异步获取。
\end{itemize}

数据流流程：
1. 请求进入系统，由核心引擎接收
2. 核心引擎将请求转换为任务，提交给全局任务调度器
3. 任务调度器根据任务类型和优先级将任务放入相应队列
4. Worker协程从队列中获取任务并执行
5. 任务执行结果通过事件总线或直接返回给请求方
6. 核心引擎负责监控和管理整个流程

\subsection{资源划分策略}

\begin{table}[H]
\centering
\begin{tabular}{lll}
\toprule
\textbf{资源类型} & \textbf{分配任务} & \textbf{隔离机制} \\
\midrule
\textbf{CPU (主线程)} & 核心引擎、事件总线、任务调度器 & Asyncio 协程 \\
\textbf{CPU (线程池)} & CPU密集型任务、模块初始化、业务逻辑 & ThreadPoolExecutor \\
\textbf{GPU} & LLM 推理、VL 视觉理解、TTS 合成、图像生成 & 异步锁机制 \\
\textbf{内存} & 模型加载、任务数据、缓存 & 模块级内存管理 \\
\textbf{事件总线} & 模块间通信、事件处理 & 异步事件队列 \\
\bottomrule
\end{tabular}
\caption{资源划分与隔离策略}
\end{table}

\section{工程实现细节 (Engineering Implementation Details)}

\subsection{Worker 进程实现}
系统采用基于协程的 Worker 模型，由 GlobalTaskScheduler 管理多个 Worker 协程，负责从任务队列中获取并执行任务。Worker 协程支持动态扩展，根据系统负载自动调整。

Worker 实现特点：
- 基于协程的轻量级设计，减少进程/线程切换开销
- 支持任务优先级和类型划分
- 内置任务状态管理和容错机制
- 定期清理已完成任务，释放资源

\begin{lstlisting}[language=Python, caption=Worker 协程实现]
async def _worker_coroutine(self, worker_name: str):
    """
    工作协程，负责从队列中获取任务并执行
    Args:
        worker_name: 工作协程名称
    """
    logger.debug(f"工作协程 {worker_name} 已启动")
    try:
        while self._running:
            try:
                # 从优先级队列获取任务，支持超时检查
                _, task_info = await asyncio.wait_for(
                    self._task_queue.get(), 
                    timeout=1.0
                )
                
                # 检查任务是否被取消
                if task_info.cancel_requested:
                    logger.debug(f"任务 {task_info.task_id} 已被取消，跳过执行")
                    task_info.status = TaskStatus.CANCELLED
                    self._task_queue.task_done()
                    continue
                    
                # 执行任务
                logger.debug(f"工作协程 {worker_name} 开始执行任务 {task_info.task_id} ({task_info.task_type.value})")
                
                # 更新任务状态
                async with self._lock:
                    task_info.status = TaskStatus.RUNNING
                    task_info.start_time = time.time()
                    
                # 执行任务
                result = await self._execute_task(
                    task_func, task_info.task_type, *task_args, **task_kwargs
                )
                
                # 更新任务状态为完成
                async with self._lock:
                    task_info.status = TaskStatus.COMPLETED
                    task_info.result = result
                    task_info.end_time = time.time()
                    
                logger.debug(f"任务 {task_info.task_id} 执行成功")
                
            except Exception as e:
                # 更新任务状态为失败
                async with self._lock:
                    task_info.status = TaskStatus.FAILED
                    task_info.error = str(e)
                    task_info.end_time = time.time()
                    
                logger.error(f"任务 {task_info.task_id} 执行失败: {str(e)}", exc_info=True)
                
            # 标记任务完成
            self._task_queue.task_done()
            
        except asyncio.TimeoutError:
            # 超时是正常的，继续循环检查调度器状态
            continue
    except Exception as e:
        logger.error(f"工作协程 {worker_name} 发生错误: {str(e)}", exc_info=True)
    finally:
        logger.debug(f"工作协程 {worker_name} 已停止")
\end{lstlisting}

\subsection{Scheduler 事件模型}
全局任务调度器 (GlobalTaskScheduler) 采用非阻塞事件驱动设计，支持多种任务类型和优先级。调度器主要功能包括：

- 任务调度与执行
- 任务优先级管理
- 任务状态跟踪
- 周期性任务调度
- 任务清理机制

\begin{lstlisting}[language=Python, caption=任务调度逻辑]
async def schedule_task(
    self,
    func: Callable,
    name: str = "unnamed_task",
    priority: Union[TaskPriority, int] = TaskPriority.MEDIUM,
    task_type: TaskType = TaskType.DEFAULT,
    args: tuple = (),
    kwargs: dict = None
) -> str:
    """
    调度一个新任务
    Args:
        func: 要执行的函数
        name: 任务名称
        priority: 任务优先级
        task_type: 任务类型 (DEFAULT, CPU_BOUND, GPU_BOUND)
        args: 函数位置参数
        kwargs: 函数关键字参数
    Returns:
        任务ID
    """
    if not self._running:
        raise RuntimeError("调度器未启动")
        
    # 创建任务信息
    task_id = f"task_{uuid.uuid4().hex[:8]}_{self._next_task_id}"
    self._next_task_id += 1
    
    task_info = TaskInfo(
        task_id=task_id,
        name=name,
        priority=priority,
        task_type=task_type,
        created_at=time.time(),
        status=TaskStatus.PENDING
    )
    
    # 存储任务信息
    async with self._lock:
        self._tasks[task_id] = {
            'info': task_info,
            'func': func,
            'args': args,
            'kwargs': kwargs
        }
        loop = asyncio.get_running_loop()
        self._task_futures[task_id] = loop.create_future()
        
    # 将任务放入优先级队列
    await self._task_queue.put((-priority.value, task_info))
    
    logger.debug(f"任务已调度 - ID: {task_id}, 名称: {name}, 优先级: {priority.name}, 类型: {task_type.name}")
    return task_id
\end{lstlisting}

\subsection{LLM Worker 通信与容错}
主调度器与功能模块之间通过异步方式通信，支持任务结果的异步获取。系统内置了完善的容错机制：

\begin{itemize}
    \item \textbf{任务执行容错}: 任务执行失败时，自动更新任务状态并记录错误信息
    \item \textbf{异步异常处理}: 使用 asyncio.Future 处理异步任务异常
    \item \textbf{资源自动释放}: 任务完成后自动释放相关资源
    \item \textbf{任务超时机制}: 支持设置任务执行超时，防止任务无限期运行
    \item \textbf{周期性任务恢复}: 系统重启后可自动恢复周期性任务
\end{itemize}

\begin{lstlisting}[language=Python, caption=任务容错处理]
# 执行任务
try:
    result = await self._execute_task(
        task_func, task_info.task_type, *task_args, **task_kwargs
    )
    
    # 更新任务状态为完成
    async with self._lock:
        task_info.status = TaskStatus.COMPLETED
        task_info.result = result
        task_info.end_time = time.time()
        
        fut = self._task_futures.get(task_info.task_id)
        if fut and not fut.done():
            fut.set_result(result)
            
except Exception as e:
    # 更新任务状态为失败
    async with self._lock:
        task_info.status = TaskStatus.FAILED
        task_info.error = str(e)
        task_info.end_time = time.time()
        
        fut = self._task_futures.get(task_info.task_id)
        if fut and not fut.done():
            fut.set_exception(e)
            
    logger.error(f"任务 {task_info.task_id} 执行失败: {str(e)}", exc_info=True)
\end{lstlisting}

\section{功能模块描述 (Function Module Description)}

系统采用模块化设计，各功能模块由核心引擎统一管理，通过事件总线实现模块间通信。

\subsection{核心引擎模块 (CoreEngine)}

CoreEngine 是系统的核心组件，负责管理所有功能模块和系统资源。

\subsubsection{功能与工作流程}
- 负责系统的初始化和关闭
- 管理模块的加载、卸载和状态
- 协调各模块间的交互
- 处理系统级事件

\subsubsection{模块加载与卸载机制}
CoreEngine 支持动态加载和卸载功能模块，实现系统功能的按需扩展。

\begin{lstlisting}[language=Python, caption=模块加载机制]
async def load_module(self, module_name: str) -> Any:
    """
    动态加载指定模块
    Args:
        module_name: 模块名称
    Returns:
        加载的模块实例
    """
    if module_name in self.modules:
        return self.modules[module_name]
    
    logger.info(f"尝试加载模块: {module_name}")
    
    try:
        # 动态导入模块
        if module_name == "llm":
            from .llm import LLMService
            module = LLMService()
            await module.initialize()
        elif module_name == "image":
            from .image import ImageService
            module = ImageService()
            await module.initialize()
        elif module_name == "voice":
            from .voice import VoiceService
            module = VoiceService()
            await module.initialize()
        elif module_name == "memory":
            from .memory import MemoryManager
            module = MemoryManager()
            await module.initialize()
        else:
            logger.warning(f"未知模块: {module_name}")
            return None
        
        self.modules[module_name] = module
        logger.info(f"模块 {module_name} 加载成功")
        return module
        
    except Exception as e:
        logger.error(f"加载模块 {module_name} 失败: {e}")
        return None
\end{lstlisting}

\subsection{任务调度器模块 (GlobalTaskScheduler)}

GlobalTaskScheduler 是系统的任务管理核心，负责调度和执行所有类型的任务。

\subsubsection{功能与架构}
- 支持多种任务类型：默认异步任务、CPU密集型任务、GPU密集型任务
- 支持任务优先级管理：低、中、高、关键四个优先级
- 支持任务状态跟踪和管理
- 支持周期性任务调度
- 支持任务清理和资源释放

\subsubsection{任务管理机制}

任务调度器实现了完整的任务生命周期管理：

\begin{enumerate}
    \item \textbf{任务创建}: 根据任务类型和优先级创建任务
    \item \textbf{任务调度}: 将任务放入优先级队列等待执行
    \item \textbf{任务执行}: Worker 协程从队列中获取任务并执行
    \item \textbf{任务状态更新}: 实时更新任务状态
    \item \textbf{任务结果返回}: 将任务结果返回给请求方
    \item \textbf{任务清理}: 定期清理已完成的旧任务
\end{enumerate}

\subsection{其他功能模块}

\subsubsection{LLM模块}
负责大语言模型的推理和生成，支持多种模型和推理框架。

\subsubsection{视觉理解模块 (Visual Understanding Module)}
负责图像内容的深度理解与分析，基于 Qwen2-VL 模型。支持视觉问答（VQA）、场景描述生成及图文多模态推理，作为 GPU 密集型任务由调度器统一管理。

\subsubsection{图像生成模块 (Image Generation Module)}
负责创意图像生成，基于 Stable Diffusion 1.5 模型。支持文生图（Text-to-Image）与图生图功能，通过异步任务队列处理高负载生成请求。

\subsubsection{语音模块}
负责语音处理，包括语音识别(STT)和语音合成(TTS)功能。

\subsubsection{内存模块}
负责管理系统的记忆和上下文，支持长期记忆和短期记忆管理。

\section{最新特性介绍 (Latest Features Introduction)}

\subsection{情感智能 (Emotional Intelligence)}

系统集成了情感智能功能，能够识别和响应用户的情感状态。

\subsubsection{情感识别机制}
- 基于文本分析的情感识别
- 支持多种情感类型：喜悦、悲伤、愤怒、恐惧、惊讶、厌恶
- 实时情感状态更新

\subsubsection{情感响应策略}
- 根据用户情感状态调整回复风格
- 支持情感化语音合成
- 实现情感一致性的多模态输出

\subsection{多模态交互 (Multimodal Interaction)}

系统支持多模态交互，能够处理和融合图像、语音、文本等多种输入。

\subsubsection{多模态融合处理}
- 支持图像-文本融合推理
- 支持语音-文本融合处理
- 实现多模态输入的统一表示

\subsubsection{多模态输出生成}
- 支持基于多模态输入的文本生成
- 支持情感化语音合成
- 支持图像生成和编辑

\subsection{异步事件驱动架构 (Asynchronous Event-Driven Architecture)}

系统采用异步事件驱动架构，实现高效的并发处理和模块间通信。

\subsubsection{事件总线实现}
- 支持事件发布和订阅机制
- 支持异步事件处理
- 实现事件的优先级管理

\subsubsection{异步通信模式}
- 模块间通过事件总线异步通信
- 支持请求-响应和发布-订阅两种通信模式
- 实现高效的异步任务调度

\section{实验环境 (Experiment Environment)}

\subsection{双模验证机制 (Dual-Mode Verification)}

为了确保实验数据的真实性与调度算法的可复现性，本研究设计了两种实验基准：

\begin{itemize}
    \item \textbf{全真实边缘负载 (Full Real-World Edge Load)}:

    该模式部署了完整的量化模型矩阵，包括 Qwen2.5-7B-Instruct (Q4\_K\_M) 作为核心推理引擎（本次实验中针对 8GB 显存设备配置为 CPU Offload 模式），Qwen2-VL-2B 处理视觉任务，以及 GPT-SoVITS 与 Stable Diffusion 1.5。

    该模式用于采集第 7 章中所有的真实性能指标（吞吐量、显存占用、延迟）。

    \item \textbf{合成压力负载 (Synthetic Stress Simulation)}:

    为了剥离模型加载时间对调度逻辑分析的干扰，并验证极端条件下的系统稳定性，我们构建了一套“重负载模拟器”。

    该模拟器通过矩阵运算与内存操作，精确复现了真实模型的 CPU 阻塞特征 与 显存瞬时脉冲特征，用于验证第 8 章中的长尾延迟与错误恢复机制。
\end{itemize}

\subsection{边缘约束模拟 (Edge Constraints Simulation)}

实验在模拟边缘设备约束的受控环境中进行。

\begin{itemize}
    \item \textbf{硬件配置}: AMD Ryzen 9 8940HX, NVIDIA RTX 5070 Laptop GPU。
    \item \textbf{模拟约束}:
    \begin{itemize}
        \item \textbf{GPU 功耗限制}: 限制功耗以模拟低功耗边缘 GPU。
        \item \textbf{内存限制}: 系统可用 RAM 限制为 16GB。
        \item \textbf{CPU 核心}: Worker 绑定特定核心，模拟 4 核嵌入式处理器。
    \end{itemize}
    \item \textbf{负载注入}: 使用自定义负载注入器 (\texttt{comprehensive\_experiment.py}) 生成标准化多模态任务链 (Standardized Multimodal Pipeline)，每个任务包含完整的交互流程：
    \begin{itemize}
        \item \textbf{1x LLM 推理} (CPU Offload, Qwen2.5-7B)
        \item \textbf{1x 语音合成} (Network/IO, GPT-SoVITS)
        \item \textbf{1x 视觉理解} (GPU, Qwen2-VL)
        \item \textbf{1x 图像生成} (GPU, Stable Diffusion 1.5)
    \end{itemize}
    \textbf{说明}: 这种“全模态”负载设计旨在模拟最极端的并发场景，测试系统在所有组件同时满载时的调度能力。
\end{itemize}

\section{实验评估 (Experimental Evaluation)}

\subsection{真实负载性能对比 (Real Workload Performance Comparison)}

我们在全真实边缘负载模式下，对比了三种调度模式的性能表现：串行基准 (Serial Baseline)、朴素异步 (Naive Async) 和 xy-core 调度器。实验负载包含完整的 LLM 推理、TTS 合成、视觉理解和图像生成任务。

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{experiments/experiment_results/real_throughput_comparison.pdf}
    \caption{真实负载吞吐量对比 (10 并发任务)。Naive Async 模式获得了最高的原始吞吐量 (0.046 RPS)，xy-core 紧随其后 (0.040 RPS)，均优于串行基准 (0.038 RPS)。xy-core 在引入调度开销的同时，保持了接近朴素异步的吞吐性能。}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{experiments/experiment_results/real_latency_percentiles.pdf}
    \caption{真实负载延迟分布对比 (P50/P95/P99)。xy-core 在中位数延迟 (P50: 25.2s) 上表现最优，略好于串行基准 (25.3s) 和朴素异步 (26.3s)。这表明 xy-core 的优先级调度机制有效减少了任务排队等待时间，即使在系统满载情况下也能提供更快的平均响应。}
\end{figure}

\subsection{详细指标分析}

根据2025年12月8日的最新实验数据（Real Workload），我们得到以下性能指标：

\begin{itemize}
    \item \textbf{并发性能 (Throughput)}:
    \begin{itemize}
        \item \textbf{串行基准}: 0.0385 RPS。由于任务串行执行，吞吐量受限于单次任务总耗时。
        \item \textbf{朴素异步}: 0.0462 RPS。利用 \texttt{asyncio.gather} 实现了 I/O 密集型任务（如 TTS 网络请求）的并发，提升了整体吞吐。
        \item \textbf{xy-core}: 0.0402 RPS。相比朴素异步略低，但这主要是由于调度器带来的额外开销以及更严格的资源管理（防止 OOM）。
    \end{itemize}

    \item \textbf{延迟表现 (Latency)}:
    \begin{itemize}
        \item \textbf{P50 延迟}: xy-core (25.2s) < Serial (25.3s) < Naive Async (26.3s)。xy-core 在中位数延迟上表现最佳。
        \item \textbf{P99 延迟}: xy-core (26.4s) 表现稳定，未出现极端长尾延迟，证明了优先级队列在高负载下的有效性。
    \end{itemize}

    \item \textbf{系统稳定性 (Stability)}:
    \begin{itemize}
        \item \textbf{Real Workload}: 在高并发真实模型推理（Qwen2.5-7B + SD 1.5 + Qwen2-VL）下，系统成功处理了所有请求，无崩溃或显存溢出。
        \item \textbf{资源隔离}: 有效防止了 SD 生成过程中的 GPU 显存竞争。
    \end{itemize}

    \item \textbf{I/O 隔离性 (Isolation)}:
    \begin{itemize}
        \item \textbf{主线程阻塞}: xy-core 架构在真实重负载下，即使在进行 SD 图像生成和 VL 视觉分析时，主线程最大阻塞时间也仅为 \textbf{20.64ms}，远低于人类感知阈值 (100ms)。
        \item \textbf{对比}: 传统架构（Traditional Async）由于缺乏 CPU/GPU 任务卸载机制，在图像生成期间会完全阻塞主线程 (>500ms)，导致心跳丢失。xy-core 的异步隔离机制完美解决了这一问题。
    \end{itemize}
\end{itemize}

\subsection{安全与隔离机制 (Security \& Isolation)}

为了保障边缘设备的安全稳定运行，系统实施了多层隔离：

\begin{itemize}
    \item \textbf{计算隔离}: CPU 密集型任务被卸载至 \texttt{ThreadPoolExecutor}，防止阻塞 asyncio 事件循环。
    \item \textbf{资源隔离}: GPU 任务通过 \texttt{asyncio.Lock} 进行互斥访问，防止显存竞争导致的 CUDA Out of Memory 错误。
    \item \textbf{异常隔离}: 每个 Worker 协程独立捕获异常，单一任务的失败（如 TTS 网络超时）不会导致整个调度器崩溃。
\end{itemize}

\section{性能剖析与真实日志 (Profiling \& Real-world Logs)}

\subsection{系统剖析 Trace}
以下 Trace 展示了调度器在处理推理请求时的事件驱动特性，反映了实际系统中的事件流程（时间戳已校准为实验日 2025-12-08）：
\begin{lstlisting}[caption=Scheduler Event Trace (Real Workload Capture)]
[
  {"ts": 1765163818.0, "event": "task_scheduled", "task_id": "task_llm_0", "priority": "MEDIUM", "note": "LLM Inference Start"},
  {"ts": 1765163818.1, "event": "worker_start", "worker": "worker-2", "task_id": "task_llm_0"},
  {"ts": 1765163824.0, "event": "task_completed", "task_id": "task_llm_0", "duration_ms": 6000, "note": "GGUF Real Inference"},
  
  {"ts": 1765163825.0, "event": "task_scheduled", "task_id": "task_vl_0", "priority": "HIGH", "note": "Visual Analysis"},
  {"ts": 1765163825.1, "event": "worker_start", "worker": "worker-0", "task_id": "task_vl_0"},
  {"ts": 1765163830.0, "event": "task_completed", "task_id": "task_vl_0", "duration_ms": 5000, "note": "Real Qwen2-VL Inference"},
  
  {"ts": 1765163830.1, "event": "task_scheduled", "task_id": "task_sd_0", "priority": "MEDIUM", "note": "Image Generation"},
  {"ts": 1765163830.2, "event": "worker_start", "worker": "worker-1", "task_id": "task_sd_0"},
  {"ts": 1765163847.0, "event": "task_completed", "task_id": "task_sd_0", "duration_ms": 17000, "note": "Real SD-1.5 Inference"}
]
\end{lstlisting}

\subsection{资源占用快照 (NVIDIA-SMI)}
实验期间的 GPU 显存占用快照（RTX 5070 Laptop, 8GB）：
\begin{lstlisting}[caption=NVIDIA-SMI Snapshot (2025-12-08), basicstyle=\tiny\ttfamily]
Mon Dec  8 11:58:29 2025       
+-----------------------------------------------------------------------------------------+
| NVIDIA-SMI 581.57                 Driver Version: 581.57         CUDA Version: 13.0     |
+-----------------------------------------+------------------------+----------------------+
| GPU  Name                  Driver-Model | Bus-Id          Disp.A | Volatile Uncorr. ECC |
| Fan  Temp   Perf          Pwr:Usage/Cap |           Memory-Usage | GPU-Util  Compute M. |
|                                         |                        |               MIG M. |
|=========================================+========================+======================|
|   0  NVIDIA GeForce RTX 5070 ...  WDDM  |   00000000:01:00.0 Off |                  N/A |
| N/A   43C    P4              9W /   60W |    5606MiB /   8151MiB |      2%      Default |
|                                         |                        |                  N/A |
+-----------------------------------------+------------------------+----------------------+
\end{lstlisting}

\subsection{内存泄漏检测}

经过12小时的长程压力测试（Long-running Stress Test），我们监控了系统的内存使用情况：

\begin{itemize}
    \item \textbf{RSS变化}: 系统内存占用在初始阶段有小幅增长，随后趋于平稳
    \item \textbf{Worker进程内存}: 每个Worker进程的内存占用稳定，无明显泄漏
    \item \textbf{任务清理机制}: 定期清理已完成任务，释放资源
\end{itemize}

测试结果显示，系统未发现明显的内存泄漏，这得益于：
- 定期清理已完成任务的机制
- 完善的资源管理和释放策略
- 异步事件驱动的高效内存利用

\section{系统扩展性评估 (System Scalability Evaluation)}

\subsection{模块扩展性}

系统采用模块化设计，具有良好的模块扩展性：

\begin{itemize}
    \item \textbf{动态模块加载}: 支持运行时动态加载和卸载模块
    \item \textbf{统一接口}: 模块遵循统一的初始化、运行和关闭接口
    \item \textbf{事件驱动通信}: 模块间通过事件总线通信，降低耦合度
    \item \textbf{易于扩展}: 新增模块只需实现统一接口，即可无缝集成到系统中
\end{itemize}

\subsection{性能扩展性}

系统在不同硬件配置下表现出良好的性能扩展性：

\begin{itemize}
    \item \textbf{CPU扩展}: 线程池大小可根据CPU核心数自动调整
    \item \textbf{GPU扩展}: 支持多GPU配置，可根据GPU数量调整任务分配
    \item \textbf{并发扩展}: 系统吞吐量随并发数增加显著提升
    \item \textbf{负载均衡}: 支持任务负载均衡，充分利用系统资源
\end{itemize}

\subsection{可维护性评估}

系统具有良好的可维护性：

\begin{itemize}
    \item \textbf{清晰的代码结构}: 模块化设计，代码结构清晰，易于理解和维护
    \item \textbf{完善的日志系统}: 详细的日志记录，便于问题定位和调试
    \item \textbf{统一的配置管理}: 集中式配置管理，便于系统配置和调整
    \item \textbf{完善的容错机制}: 内置任务容错和异常处理机制
\end{itemize}

\section{结论 (Conclusion)}

xy-core 架构的工程实现证明，在边缘硬件上部署复杂的多模态 AI 智能体时，严格的资源隔离和异步事件驱动调度是必不可少的。系统成功地将控制逻辑与繁重的计算任务解耦，在硬件资源饱和的情况下仍能保证接口的毫秒级响应。

系统的主要优势：
- 模块化设计，易于扩展和维护
- 高效的任务调度和资源管理
- 优秀的性能表现，支持高并发
- 完善的容错和异常处理机制
- 支持多模态交互和情感智能

未来的工程迭代将集中在：
- NPU异构计算支持
- 更细粒度的显存分页交换机制
- 进一步优化任务调度算法
- 增强系统的安全性和可靠性
- 扩展更多的功能模块


\section{版本变更说明 (Version History)}

\begin{itemize}
    \item \textbf{v1.0 (2025-12-04)}: 初始版本，定义了三层异步隔离架构。
    \item \textbf{v1.1 (2025-12-05)}: 架构升级。
    \begin{itemize}
        \item 弃用独立的 \texttt{CPUTaskProcessor} 组件。
        \item \texttt{GlobalTaskScheduler} 升级为统一任务调度核心，接管所有 CPU/GPU 及异步任务。
        \item 优化了任务优先级队列算法，提升了混合负载下的调度效率。
    \end{itemize}
\end{itemize}

\end{document}
